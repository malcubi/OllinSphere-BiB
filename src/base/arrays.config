!$Header: /usr/local/ollincvs/Codes/OllinSphere-BiB/src/base/arrays.config,v 1.149 2023/08/22 17:58:03 malcubi Exp $

! **************************************
! ***   FILE FOR ARRAY DECLARATION   ***
! **************************************

!               VERY IMPORTANT  (PLEASE READ)
!
! * Comments must be preceded by exclamation marks (like in Fortran).
!
! * Declare only one array per line.
!
! * Arrays must be declared either REAL or COMPLEX.
!
! * Control statements for each array are indicated in a comment,
!   and MUST include the following keywords:
!
!   SYMMETRY, INTENT, STORAGE
!
!   Notice that they must always come in this order, and they
!   must be separated by commas.
!
! * The keyword SYMMETRY can only have three values:
!
!   SYMMETRY = +1        The variable is even at origin.
!                        (no space is allowed between + and 1)
!
!   SYMMETRY = -1        The variable is odd at origin.
!                        (no space is allowed between - and 1)
!
!   SYMMETRY =  0        The variable will NOT be touched when
!                        updating the symmetries at the origin.
!
!   NOTE:  In fact it is possible to set SYMMETRY equal to a regular
!          expression that evaluates to plus or minus 1, but there
!          can be no white spaces or perl will complain, e.g.:
!
!   SYMMETRY = +(1.d0-2.d0*mod(a,2)) or SYMMETRY = -(1.d0-2.d0*mod(a,2))
!
! * The keyword INTENT can have one of the following values:
!
!   INTENT = EVOLVE      The array is a main dynamical variable
!                        and will be updated during the evolution
!                        loop.  For each array of this type named
!                        "var", three extra arrays will be created:
!
!                        var_p = previous time level
!                        svar  = source term for evolution
!                        var_a = auxiliary array
!
!   INTENT = AUXILIARY   The array is not one of the main evolved variables,
!                        but can contain other important variables (radius,
!                        derivatives, etcetera).
!
!   INTENT = OUTPUT      The array will be calculated for output,
!                        so memory will only be allocated if we want
!                        output for this array.
!
!   INTENT = POINTER     This array is actually a pointer.  They are
!                        declared with STORAGE always, but they are
!                        not actually allocated.
!
! * The keyword STORAGE can have one of the following values:
!
!   STORAGE = ALWAYS            Storage for this variable is always on.
!                               If the variable is of type OUTPUT this
!                               means it will be on when we need output.
!
!   STORAGE = CONDITIONAL(*)    In this case storage will be conditional
!                               on the condition inside the parenthesis.
!                               Notice that the condition must be a correctly
!                               formatted Fortran logical statement involving
!                               one of the parameters of the code (see e.g. shift).
!
! * The keyword ONELEVEL, when present, indicates that the array has only one
!   grid level.  This is useful for example for the synchronization pointer.
!
! * The keyword NOBOUND, when present, indicates that an evolving array has no
!   need for a boundary condition since its source can be calculated all the way
!   to the boundary.
!
! * The keyword ZEROD, when present, indicates that the "array" is not really an
!   array but rather just a global real variable. This is useful, for example,
!   when integrating the background in a cosmological spacetime, or the proper
!   time for an observer at the origin.
!
! * The keyword PHASE, when present, indicates that the array lives in the 3D phase
!   space given by (r,pr,L), with pr the covariant radial momentum and L the total
!   angular momentum.
!
! * The keyword CHECKPOINT, when present, indicates that this array should be saved
!   at checkpoint time even if it does not evolve.


! ********************
! ***   POINTERS   ***
! ********************

! Pointers used for synchronizing, derivatives, integration, saving, interpolation and restriction.

  REAL syncvar           ! SYMMETRY = 0, INTENT = POINTER, STORAGE = ALWAYS, ONELEVEL
  REAL diffvar           ! SYMMETRY = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL intvar            ! SYMMETRY = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL savevar           ! SYMMETRY = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL interpvar         ! SYMMETRY = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL restrictvar       ! SYMMETRY = 0, INTENT = POINTER, STORAGE = ALWAYS

! Pointers used for dissipation.

  REAL dissipvar         ! SYMMETRY = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL sourcevar         ! SYMMETRY = 0, INTENT = POINTER, STORAGE = ALWAYS

! Pointer for saving ZEROD arrays.

  REAL savevar0D         ! SYMMETRY = 0, INTENT = POINTER, STORAGE = ALWAYS, ZEROD


! ****************************
! ***   AUXILIARY ARRAYS   ***
! ****************************

! These arrays are used for holding temporary information.

  REAL auxarray          ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL auxarray2         ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = ALWAYS


! ******************************
! ***   RADIAL COORDINATES   ***
! ******************************

! Radial coordinate.

  REAL r                 ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = ALWAYS

! Areal radial coordinate.

  REAL r_area            ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D1_r_area         ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = ALWAYS


! *******************
! ***   SLICING   ***
! *******************

! Lapse and derivatives.

  REAL alpha             ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND
  REAL D1_alpha          ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2_alpha          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DA_alpha		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! Second radial covariant derivative (one index up and one down) and Laplacian.

  REAL Dcov2_alpha       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Lapla_alpha       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

!                   4
! d (d alpha / r psi ) (for regularization).
!  r  r

  REAL DD_alphar         ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Bona-Masso gauge function f.

  REAL falpha            ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Proper time at origin.

  REAL tau_origin        ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = ALWAYS, ZEROD


! *****************
! ***   SHIFT   ***
! *****************

! Shift and derivative.

  REAL beta              ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (shift/="none"), NOBOUND
  REAL D1_beta           ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")
  REAL D2_beta           ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

  REAL DA_beta		 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! Time derivative of shift.
! Notice that when the evolution equation for the shift has advection terms,
! dtbeta is not quite the time derivative, but rather:  dbeta/dt = dtbeta + beta*dbeta/dr.

  REAL dtbeta            ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (shift/="none")
  REAL D1_dtbeta         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")
  REAL DA_dtbeta	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! Conformal divergence of shift and its derivative.

  REAL DIV_beta          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")
  REAL D1_DIV_beta       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! d ( beta / r) (for regularization).
!  r

  REAL DD_beta           ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! Gammadriver function.

  REAL fdriver           ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (shift/="none"), NOBOUND
  REAL D1_fdriver        ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")
  REAL DA_fdriver        ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")


! **************************
! ***   SPATIAL METRIC   ***
! **************************

! The spatial metric takes the following form:
!
!   2       4  /      2      2       2 \
! dl  =  psi   |  A dr  + B r  dOmega  |
!              \                       /
!
!         4 phi /      2      2       2 \
!     =  e      |  A dr  + B r  dOmega  |
!               \                       /

! Conformal factor and derivatives (remember that psi = exp(phi)).
! I also define arrays psi2 = psi**2 and psi4 = psi**4, since they
! are needed many times.


  REAL phi               ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND
  REAL D1_phi            ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2_phi            ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DA_phi		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

  REAL psi               ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL psi2              ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL psi4              ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL D1_psi            ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2_psi            ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Inverse square conformal factor: chi = 1/psi**n = exp(-n*phi)

  REAL chi               ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND
  REAL D1_chi            ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2_chi            ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DA_chi		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

!                 4
! d (d phi / r psi ) (for regularization).
!  r  r

  REAL DD_phir           ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Conformal spatial metric.

  REAL A                 ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND
  REAL D1_A              ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2_A              ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL B                 ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND
  REAL D1_B              ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2_B              ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DA_A		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")
  REAL DA_B		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! d (d A / r)  and  d (d B / r)  (for regularization).
!  r  r              r  r

  REAL DD_Ar             ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DD_Br             ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Physical spatial metric: APHYS = exp(4*phi)*A, BPHYS = exp(4*phi)*B

  REAL APHYS             ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL BPHYS             ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! Determinant of conformal metric (times r**2) AB2 := A*B**2 and ists derivatives
! (must remain static for langrangian evolution).

  REAL AB2               ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS, CHECKPOINT
  REAL D1_AB2            ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS, CHECKPOINT
  REAL D2_AB2            ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS, CHECKPOINT

! Radial metric for areal radius.

  REAL GRR               ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! Embedding function.

  REAL hembed            ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! *******************************
! ***   EXTRINSIC CURVATURE   ***
! *******************************

! Trace of extrinsic curvature and derivatives.

  REAL trK               ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL D1_trK            ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DA_trK		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! Mixed radial component of traceless extrinsic curvature: KTA = KT^r_r.
! (Notice that for mixed indices, the conformal and physical components
! are in fact identical).

  REAL KTA               ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL D1_KTA		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DA_KTA		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! Mixed angular component of traceless extrinsic curvature: KTB = KT^theta_theta.
! Notice that the traceless condition implies that we must have: KTA + 2 KTB = 0,
! so the angular component is in fact not evolved.

  REAL KTB               ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D1_KTB		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DA_KTB		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! Mixed components of full physical extrinsic curvature: KA = K^r_r, KB = K^theta_theta.
! Notice that we must have: KA + 2 KB = trK.

  REAL KAPHYS            ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL KBPHYS            ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Square of extrinsic curvature:  K2 = K_ij K^ij = KA**2 + 2 KB**2
!                                    = KTA**2 + 2 KTB**2 + trK**2/3

  REAL K2                ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS


! **************************
! ***   DELTA VARIABLE   ***
! **************************

! BSSN Delta variable. The definition in terms of metric variables is:
! Deltar = (1/A) ((dA/dr)/(2A) - (dB/dr)/B) - 2 r lambda )

  REAL Deltar            ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL D1_Deltar         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DA_Deltar	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! Initial value of Delta.  This is important for the shift conditions
! since in many cases Delta is non-trivial at t=0.

  REAL Deltar0           ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS, CHECKPOINT

! d ( Deltar / r) (for regularization).
!  r

  REAL DD_Deltar         ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Delta in terms of its definition.

  REAL DeltaAB           ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D1_DeltaAB        ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS


! ************************************
! ***   REGULARIZATION VARIABLES   ***
! ************************************

! lambda = (1 - A/B)/r**2

  REAL lambda            ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND
  REAL D1_lambda         ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2_lambda         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DA_lambda	 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! Klambda = (KTA - KTB)/r**2 = (3/2) KTA / r**2

  REAL Klambda           ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL D1_Klambda        ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DA_Klambda        ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! lambda2 = lambda/psi**n

  REAL lambda2           ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND
  REAL D1_lambda2        ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2_lambda2        ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DA_lambda2	 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")

! Klambda2 = Klambda/psi**n

  REAL Klambda2          ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL D1_Klambda2       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DA_Klambda2       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (shift/="none")


! **************************
! ***   3-RICCI TENSOR   ***
! **************************

! Notice that this is the full physical Ricci tensor,
! and not the conformal Ricci.

! Mixed components of Ricci tensor:  RICA = R^r_r

  REAL RICA              ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Scalar curvature (trace of Ricci): RSCAL

  REAL RSCAL             ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS


! **********************
! ***   Z4c ARRAYS   ***
! **********************

! Z4 theta constraint variable. Must vanish for physical solutions.
! They always have storage, but are set to zero and do not evolve
! for BSSN.

  REAL z4theta           ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = ALWAYS

  REAL D1_z4theta        ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DA_z4theta        ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((formulation=="z4c").and.(shift/="none"))


! ***********************
! ***   WEYL TENSOR   ***
! ***********************

! Mixed components of electric part of Weyl: EWEYLA = E^r_r, EWEYLB = E^theta_theta.
! (Remember that the magnetic part of Weyl vanishes in spherical symmetry).

  REAL EWEYLA            ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL EWEYLB            ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = ALWAYS


! ********************************
! ***   CURVATURE INVARIANTS   ***
! ********************************

! Real part of invariant I (the imaginary part vanishes in sherical symmetry).

  REAL invariantI        ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! Real part of invariant J (the imaginary part vanishes in sherical symmetry).

  REAL invariantJ        ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! ***************************
! ***   4D RICCI SCALAR   ***
! ***************************

  REAL Ricci4D           ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! 4D Ricci escalar in the Einstein frame.

  REAL Ricci4D_E         ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! ***********************
! ***   CONSTRAINTS   ***
! ***********************

! Hamiltonian constraint.

  REAL ham               ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL hamabs            ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! Momentum constraint.

  REAL mom               ! SYMMETRY = -1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL momabs            ! SYMMETRY = -1, INTENT = OUTPUT, STORAGE = ALWAYS

! CDeltar:   A Deltar - [ (dA/dr)/(2A) - (dB/dr)/B) - 2 r lambda ]

  REAL CDeltar           ! SYMMETRY = -1, INTENT = OUTPUT, STORAGE = ALWAYS

! Clambda:   r**2*lambda - (1 - A/B)

  REAL Clambda           ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! CKlambda:  r**2*Klambda - (KTA - KTB)

  REAL CKlambda          ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! ******************
! ***   VIRIAL   ***
! ******************

! Two virial-like integrals.  Look at the routine virial.f90
! to see how they are defined.

  REAL virial1           ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL virial2           ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! ********************************************
! ***   EXPANSION OF OUTGOING NULL LINES   ***
! ********************************************

! Expansion of outgoing null lines.

  REAL expansion         ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! *****************************
! ***   COORDINATE SPEEDS   ***
! *****************************

! Coordinate speed of light:  vl = alpha/sqrt(A)/psi**2

  REAL vlight            ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! Bona-Masso gauge speed:  vg = alpha*sqrt(f(alpha))/sqrt(A)/psi**2

  REAL vgauge            ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! *********************************
! ***   GEOMETRIC EIGENFIELDS   ***
! *********************************

! Lapse gauge eigenfields:
!
! wpm_gauge = (alpha sqrt(f A) psi**2) trK +- dalpha/dr

  REAL wp_gauge          ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL wm_gauge          ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! Eigenfields associated with KTA:
!
! wpm_eta  =  (sqrt(A) psi**2) sqrt((2 eta - 1)/3) (KTA - 2/3 trK)
!          +- ( (DA/A - DB/B)/3 - (2/3) A Deltar + (4/3) dphi/dr )

  REAL wp_eta            ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL wm_eta            ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! Non-propagating eigenfield:
!
! wDelta  =  4 eta Dphi - (eta-2)/2 DA/A - A Delta

  REAL wDelta            ! SYMMETRY = -1, INTENT = OUTPUT, STORAGE = ALWAYS


! *************************
! ***   STRESS-ENERGY   ***
! *************************

!                                          ab
! rho:       Energy density:  rho = n  n  T
!                                    a  b
!                                                        a
! JA:        Momentum density (index down):  JA =  - n  T
!                                                     a   r
!                                                       r
! SAA:       Radial component of stress tensor:  SAA = S
!                                                       r
!                                                       theta
! SBB:       Angular component of stress tensor:  SB = S
!                                                       theta
!
! trS:       Trace of stress tensor:  trS = SAA + 2*SBB

  REAL rho               ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")

  REAL JA                ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")

  REAL SAA               ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")
  REAL SBB               ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")
  REAL trS               ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")

! SLL = (SAA - SBB)/r**2

  REAL SLL               ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")

! Density times r**2  (this reflects better energy content).

  REAL rho_r2            ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (mattertype/="vacuum")


! ****************
! ***   MASS   ***
! ****************

! mass_sch:      Schwarzschild mass:  M_sch  =  r_area (1 - 1/A) / 2
! mass_int:      Integrated mass from Hamiltonian constraint
! mass_rn        Reissner-Nordstrom mass:  M_rn = r_area (1 - 1/A + Q^2/r^2) / 2
!
! Kodama_mass:   Kodama mass
! P_Kodama :     Integrated energy flux through a sphere of radius r
!
! rho_int:       Integral of energy density
! compactness:   Compactness: C =  M_int / r_area
 
  REAL mass_sch          ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL mass_int          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype /= "vacuum")
  REAL mass_rn           ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))

  REAL Kodama_mass       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype /= "vacuum")
  REAL P_Kodama          ! SYMMETRY = +1, INTENT = EVOLVE,    STORAGE = CONDITIONAL (mattertype /= "vacuum")

  REAL rho_int           ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype /= "vacuum")
  REAL compactness       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype /="vacuum")


! ******************************
! ***   TRUMPET BLACK HOLE   ***
! ******************************

  REAL trumpet_u         ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (idata=="trumpetBH")
  REAL trumpet_v         ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (idata=="trumpetBH")


! *****************************
! ***   REAL SCALAR FIELD   ***
! *****************************

! Scalar field.

  REAL scalar_phi        ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"scalar")), NOBOUND

! Derivatives.  Notice that D1_phi must be equal to xi to numerical error.

  REAL D1_scalar_phi     ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"scalar"))
  REAL D2_scalar_phi     ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"scalar"))
  REAL DA_scalar_phi     ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"scalar")).and.(shift/="none"))

! Spatial derivative: Xi = dphi/dr

  REAL scalar_xi         ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"scalar")), NOBOUND

! Time derivative:  Pi = n^m d_m phi = (dphi/dt - beta dphi/dr) / alpha

  REAL scalar_pi         ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"scalar"))

! Derivatives of Xi and Pi.

  REAL D1_scalar_xi      ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"scalar"))
  REAL D1_scalar_pi      ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"scalar"))

  REAL DA_scalar_xi      ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"scalar")).and.(shift/="none"))
  REAL DA_scalar_pi      ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"scalar")).and.(shift/="none"))

! Scalar field potential V and its derivative VP = dV/dphi.

  REAL scalar_V          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"scalar"))
  REAL scalar_VP         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"scalar"))

! Scalar eigenfields:
!
! wpm_scalar = Pi -+ Xi/(A psi**2)

  REAL wp_scalar         ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL wm_scalar         ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! ******************************
! ***   GHOST SCALAR FIELD   ***
! ******************************

! Ghost scalar field.

  REAL ghost_phi         ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"ghost")), NOBOUND

! Derivatives.  Notice that D1_phi must be equal to xi to numerical error.

  REAL D1_ghost_phi      ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"ghost"))
  REAL D2_ghost_phi      ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"ghost"))
  REAL DA_ghost_phi      ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"ghost")).and.(shift/="none"))

! Spatial derivative: Xi = dphi/dr

  REAL ghost_xi          ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"ghost")), NOBOUND

! Time derivative:  Pi = n^m d_m phi =  ( dphi/dt - beta dphi/dr) / alpha

  REAL ghost_pi          ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"ghost"))

! Derivatives of Xi and Pi.

  REAL D1_ghost_xi       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"ghost"))
  REAL D1_ghost_pi       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"ghost"))

! Advective derivatives.

  REAL DA_ghost_xi       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"ghost")).and.(shift/="none"))
  REAL DA_ghost_pi       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"ghost")).and.(shift/="none"))

! Ghost field potential V and its derivative VP = dV/dphi.

  REAL ghost_V           ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"ghost"))
  REAL ghost_VP          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"ghost"))


! **************************************
! ***   COMPLEX GHOST SCALAR FIELD   ***
! **************************************

! Same as scalar field, but for real and imaginary parts.

! Real and imaginary parts of scalar field.

  REAL complexghost_phiR      ! SYMMETRY = +(1.d0-2.d0*mod(complexghost_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexghost")), NOBOUND
  REAL complexghost_phiI      ! SYMMETRY = +(1.d0-2.d0*mod(complexghost_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexghost")), NOBOUND

! Derivatives of (phiR,phiI).  Notice that D1_phi must be equal to xi to numerical error.

  REAL D1_complexghost_phiR   ! SYMMETRY = -(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL D2_complexghost_phiR   ! SYMMETRY = +(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL DA_complexghost_phiR   ! SYMMETRY = -(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost").and.(shift/="none"))
  REAL D1_complexghost_phiI   ! SYMMETRY = -(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL D2_complexghost_phiI   ! SYMMETRY = +(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL DA_complexghost_phiI   ! SYMMETRY = -(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost").and.(shift/="none"))

! Spatial derivative: Xi = dphi/dr

  REAL complexghost_xiR       ! SYMMETRY = -(1.d0-2.d0*mod(complexghost_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL complexghost_xiI       ! SYMMETRY = -(1.d0-2.d0*mod(complexghost_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))

! Time derivative:  Pi = n^m d_m phi =  ( dphi/dt - beta dphi/dr) / alpha

  REAL complexghost_piR       ! SYMMETRY = +(1.d0-2.d0*mod(complexghost_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL complexghost_piI       ! SYMMETRY = +(1.d0-2.d0*mod(complexghost_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))

! Derivatives of Xi and Pi.

  REAL D1_complexghost_xiR    ! SYMMETRY = +(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL D1_complexghost_xiI    ! SYMMETRY = +(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL DA_complexghost_xiR    ! SYMMETRY = +(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost").and.(shift/="none"))
  REAL DA_complexghost_xiI    ! SYMMETRY = +(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost").and.(shift/="none"))
  REAL D1_complexghost_piR    ! SYMMETRY = -(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL D1_complexghost_piI    ! SYMMETRY = -(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL DA_complexghost_piR    ! SYMMETRY = -(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost").and.(shift/="none"))
  REAL DA_complexghost_piI    ! SYMMETRY = -(1.d0-2.d0*mod(complexghost_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost").and.(shift/="none"))

! Complex field potential V and its derivatives: VPR = dV/dphiR, VPI = dV/dphiI.

  REAL complexghost_V         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL complexghost_VPR       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))
  REAL complexghost_VPI       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))

! Norm for complex scalar field: sqrt(phiR**2 + phiI**2).

  REAL complexghost_phi_norm  ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complexghost"))


! ********************************
! ***   COMPLEX SCALAR FIELD   ***
! ********************************

! Same as scalar field, but for real and imaginary parts.

! Real and imaginary parts of scalar field.

  REAL complex_phiR      ! SYMMETRY = +(1.d0-2.d0*mod(complex_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complex")), NOBOUND
  REAL complex_phiI      ! SYMMETRY = +(1.d0-2.d0*mod(complex_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complex")), NOBOUND

! Derivatives of (phiR,phiI).  Notice that D1_phi must be equal to xi to numerical error.

  REAL D1_complex_phiR   ! SYMMETRY = -(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL D2_complex_phiR   ! SYMMETRY = +(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL DA_complex_phiR   ! SYMMETRY = -(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complex")).and.(shift/="none"))

  REAL D1_complex_phiI   ! SYMMETRY = -(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL D2_complex_phiI   ! SYMMETRY = +(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL DA_complex_phiI   ! SYMMETRY = -(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complex")).and.(shift/="none"))

! Spatial derivative: Xi = dphi/dr

  REAL complex_xiR       ! SYMMETRY = -(1.d0-2.d0*mod(complex_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complex")), NOBOUND
  REAL complex_xiI       ! SYMMETRY = -(1.d0-2.d0*mod(complex_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complex")), NOBOUND

! Time derivative:  Pi = n^m d_m phi = (dphi/dt - beta dphi/dr) / alpha

  REAL complex_piR       ! SYMMETRY = +(1.d0-2.d0*mod(complex_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL complex_piI       ! SYMMETRY = +(1.d0-2.d0*mod(complex_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complex"))

! Gauge derivatives for EM coupling:  d -> D = d + iqA  (just for evaluation of the stress-energy terms).

  REAL complex_gxiR      ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL complex_gxiI      ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))

  REAL complex_gpiR      ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL complex_gpiI      ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))

! Derivatives of Xi and Pi.

  REAL D1_complex_xiR    ! SYMMETRY = +(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL D1_complex_xiI    ! SYMMETRY = +(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL DA_complex_xiR    ! SYMMETRY = +(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complex")).and.(shift/="none"))
  REAL DA_complex_xiI    ! SYMMETRY = +(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complex")).and.(shift/="none"))

  REAL D1_complex_piR    ! SYMMETRY = -(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL D1_complex_piI    ! SYMMETRY = -(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL DA_complex_piR    ! SYMMETRY = -(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complex")).and.(shift/="none"))
  REAL DA_complex_piI    ! SYMMETRY = -(1.d0-2.d0*mod(complex_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complex")).and.(shift/="none"))

! Complex field potential V and its derivatives: VPR = dV/dphiR, VPI = dV/dphiI.

  REAL complex_V         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL complex_VPR       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL complex_VPI       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))

! Norm for complex scalar field: sqrt(phiR**2 + phiI**2).

  REAL complex_phi_norm  ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complex"))

! Boson density (phiR*piI  -  phiI*piR), and boson density times r**2 (to reflect better the particle content).

  REAL complex_Bdens	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))
  REAL complex_Bdens_r2	 ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complex"))

! Boson flux (index up):  (phiI*xiR  -  phiR*xiI) / (A psi^4)

  REAL complex_Bflux	 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex"))

! Boson number:   complex_NB = 4*pi*integral[ complex_Bdens*A^{1/2}*B*psi^6*r^2 dr]

  REAL complex_NB	 ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complex"))

! Auxiliary field for alternative normalizations on initial data.
! For example, the normalization of Oliver Sarbach has an extra factor
! of sqrt((2*l+1)/(4*pi)). This can be commented out when not in use.

  REAL complex_phiaux    ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complex"))


! ******************************************************
! ***   COMPLEX SCALAR FIELD WITH ANGULAR MOMENTUM   ***
! ******************************************************

! Adding the possibility of a scalar field with different values of the total angular momentum.
! At the moment this is only for initial data.

  REAL complex_phiR_l0   ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex")), NOBOUND
  REAL complex_phiR_l1   ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex")), NOBOUND
  REAL complex_phiR_l2   ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex")), NOBOUND
  REAL complex_phiR_l3   ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complex")), NOBOUND


! **********************************************
! ***   NON-MINIMALLY COUPLED SCALAR FIELD   ***
! **********************************************

! Non-minimally coupled scalar field.

  REAL nonmin_phi        ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"nonmin")), NOBOUND

! Derivatives.

  REAL D1_nonmin_phi     ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))
  REAL D2_nonmin_phi     ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))
  REAL DA_nonmin_phi     ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"nonmin")).and.(shift/="none"))

! Spatial derivative: Xi = dphi/dr

  REAL nonmin_xi         ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"nonmin")), NOBOUND

! Time derivative:  Pi = n^m d_m phi =  ( dphi/dt - beta dphi/dr) / alpha

  REAL nonmin_pi         ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))

! Derivatives of Xi and Pi.

  REAL D1_nonmin_xi      ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))
  REAL D1_nonmin_pi      ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))

  REAL DA_nonmin_xi      ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"nonmin")).and.(shift/="none"))
  REAL DA_nonmin_pi      ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"nonmin")).and.(shift/="none"))

! Scalar field potential V and its derivative VP = dV/dphi.

  REAL nonmin_V          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))
  REAL nonmin_VP         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))

! Scalar charge:  Q = r**2*dPhi/dr.

  REAL nonmin_Q  ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))

! Effective gravitational constant function f and its derivatives (fp = df/dphi, fpp = dfp/dphi).

  REAL nonmin_f          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))
  REAL nonmin_fp         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))
  REAL nonmin_fpp        ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))

! Right-hand-side of field equation for nonmin field:  Box(phi) = RHS

  REAL nonmin_rhs        ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"nonmin"))

! d(xi/r)dr (for regularization).

  REAL DD_nonmin_xir     ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = ALWAYS


! **************************
! ***   ELECTRIC FIELD   ***
! **************************

! Electric field (index up).

  REAL electric          ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"electric")), NOBOUND
  REAL D1_electric       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))
  REAL DA_electric       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"electric")).and.(shift/="none"))

! Scalar potential.

  REAL ePhi              ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"electric"))
  REAL D1_ePhi           ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))
  REAL DA_ePhi           ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"electric")).and.(shift/="none"))

! Vector potential (index down).

  REAL eAr		 ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"electric"))
  REAL D1_eAr		 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))
  REAL DA_eAr		 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"electric")).and.(shift/="none"))

! Scalar potential times lapse: eF = alpha*ePhi

  REAL eF                ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))
  REAL D1_eF		 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))

! Vector potential times lapse: eH = alpha*eAr

  REAL eH                ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))
  REAL D1_eH		 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))

! Electric charge density.

  REAL echarge           ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))

! Electric current (index up).

  REAL ecurrent          ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))

! Electric constraint: Celectric = DIV (electric) - 4 pi echarge.

  REAL Celectric         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))

! Integrated charge: eQ = 4*pi*int[ (r**2 echarge) dr]

  REAL eQ_int 	     	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))

! Charge from surface integral (divergence theorem):  eQ_surf = r**2 sqrt(A) B psi**6 E^r

  REAL eQ_surf 	     	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"electric"))

! Electric eigenfields:
!
! wpm_electric = ePhi +- eAr /(A psi**2)

  REAL wp_electric       ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL wm_electric       ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! ***********************
! ***   PROCA FIELD   ***
! ***********************

! Proca electric field (index up).

  REAL procaE            ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"proca")), NOBOUND
  REAL D1_procaE         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"proca"))
  REAL DA_procaE         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"proca")).and.(shift/="none"))

! Scalar potential.

  REAL procaPhi          ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"proca"))
  REAL D1_procaPhi       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"proca"))
  REAL DA_procaPhi       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"proca")).and.(shift/="none"))

! Vector potential (index down).

  REAL procaA            ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"proca"))
  REAL D1_procaA         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"proca"))
  REAL DA_procaA         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"proca")).and.(shift/="none"))

! Scalar potential times lapse: procaF = alpha*procaPhi

  REAL procaF            ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"proca"))
  REAL D1_procaF	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"proca"))

! Vector potential times lapse: procaH = alpha*procaA

  REAL procaH            ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"proca"))
  REAL D1_procaH	 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"proca"))

! Auxiliary potential for initial data.

  REAL procaV            ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"proca"))

! Gauss constraint.

  REAL Cproca            ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"proca"))

! Proca eigenfields:
!
! wpm_proca = procaPhi +- procaA /(A psi**2)

  REAL wp_proca          ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL wm_proca          ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! *******************************
! ***   COMPLEX PROCA FIELD   ***
! *******************************

! Proca radial component of electric field (index up).

  REAL cprocaE_R         ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca")), NOBOUND
  REAL D1_cprocaE_R      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaE_R      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

  REAL cprocaE_I         ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca")), NOBOUND
  REAL D1_cprocaE_I      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaE_I      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

! Proca angular component of electric field (index down).

  REAL cprocaXi_R        ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca")), NOBOUND
  REAL D1_cprocaXi_R     ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaXi_R     ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

  REAL cprocaXi_I        ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca")), NOBOUND
  REAL D1_cprocaXi_I     ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaXi_I     ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

! Scalar potential.

  REAL cprocaPhi_R       ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaPhi_R    ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaPhi_R    ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

  REAL cprocaPhi_I       ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaPhi_I    ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaPhi_I    ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

! Radial component of Vector potential (index down).

  REAL cprocaA_R         ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaA_R      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaA_R      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

  REAL cprocaA_I         ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaA_I      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaA_I      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

! Scalar potential times lapse: procaF = alpha*procaPhi

  REAL cprocaF_R         ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaF_R      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))

  REAL cprocaF_I         ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaF_I      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))

! Vector potential times lapse: procaH = alpha*procaA

  REAL cprocaH_R         ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaH_R	 ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))

  REAL cprocaH_I         ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaH_I	 ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+1,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))

! Angular component of Vector potential (index down).

  REAL cprocaB_R         ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaB_R      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D2_cprocaB_R      ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaB_R      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

  REAL cprocaB_I         ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaB_I      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D2_cprocaB_I      ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaB_I      ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

! Spatial derivative cprocaG := d(cprocaB)/dr.

  REAL cprocaG_R         ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaG_R      ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaG_R      ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

  REAL cprocaG_I         ! SYMMETRY = -(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL D1_cprocaG_I      ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL DA_cprocaG_I      ! SYMMETRY = +(1.d0-2.d0*mod(cproca_l+2,2)), INTENT = AUXILIARY, STORAGE = CONDITIONAL ((contains(mattertype,"complexproca")).and.(shift/="none"))

! Gauss constraint.

  REAL Ccomplexproca_R   ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL Ccomplexproca_I   ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))

! Norm for complex proca potentials and electric field.

  REAL cprocaPhi_norm    ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL cprocaA_norm      ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL cprocaB_norm      ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL cprocaE_norm      ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL cprocaXi_norm     ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))

! Proca charge density, and charge density times r**2 (to reflect better the particle content).

  REAL cproca_Qdens	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))
  REAL cproca_Qdens_r2	 ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))

! Proca charge flux (index up).

  REAL cproca_Qflux      ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))

! Proca charge integral:   cproca_Qint = 4*pi*integral[ cproca_Qdens*A^{1/2}*B*psi^6*r^2 dr]

  REAL cproca_Qint       ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"complexproca"))


! ***********************
! ***   DIRAC FIELD   ***
! ***********************

! Dirac spinor functions F and G.  See routine dirac.f90
! for an explantion of what these quantities mean.
! For a Dirac field all functions are complex, so
! they have a real and an imaginary part.
! Also, notice that F is even, while G is odd.

  REAL dirac_FR          ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL dirac_FI          ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))

  REAL dirac_GR          ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL dirac_GI          ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))

! Radial derivatives.

  REAL D1_dirac_FR       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL D1_dirac_FI       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL DA_dirac_FR       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL DA_dirac_FI       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))

  REAL D1_dirac_GR       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL D1_dirac_GI       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL DA_dirac_GR       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL DA_dirac_GI       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))

! Dirac function H = G/R and derivatives.

  REAL dirac_HR          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL dirac_HI          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))

  REAL D1_dirac_HR       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL D1_dirac_HI       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))

! Time derivatives:  Pi = n^m d_m f = (f/dt - beta df/dr) / alpha

  REAL dirac_PiFR        ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL dirac_PiFI        ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))

  REAL dirac_PiGR        ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL dirac_PiGI        ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))

! Dirac particle density and flux.

  REAL dirac_dens        ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))
  REAL dirac_flux        ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))

! Dirac density integral.

  REAL dirac_Nint        ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL (contains(mattertype,"dirac"))

! Dirac eigenfields:
!
! wpm_dirac = F +- G

  REAL wpR_dirac         ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL wmR_dirac         ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS

  REAL wpI_dirac         ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL wmI_dirac         ! SYMMETRY = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! ****************
! ***   DUST   ***
! ****************

! Rest-mass energy density in comoving frame.

  REAL dust_rho	         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dust"))

! Velocity of dust elements as seen by Eulerian observers (index up).

  REAL dust_v	         ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dust"))

! Lorentz factor: W = 1 / sqrt(1  -  A psi**4 v**2).

  REAL dust_W	         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dust"))

! Conserved rest-mass energy density measured by Eulerian observers:
!
! cD  =  dust_rho W
!
! where W is the Lorentz factor given by:
!
!        mu                                i  j                          4  2
! W = - u  n   =  1 / sqrt ( 1  -  gamma  v  v  )  =  1 / sqrt( 1 - A psi  v  )
!           mu                          ij
!

  REAL dust_cD	         ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"dust"))
  REAL D1_dust_cD	 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dust"))
  REAL DA_dust_cD	 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dust"))

! Conserved energy density measured bu Eulerian observers (difference
! between total energy density and rest-mass energy density):
!
!                               2
! cE  =  rho    -  cD  =  rho0 W  -  cD
!           ADM
!

  REAL dust_cE	         ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"dust"))
  REAL D1_dust_cE	 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dust"))
  REAL DA_dust_cE	 ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dust"))

! Conserved momentum density measured by Eulerian observers (index down):
!
!              2        4
! cS  =  rho0 W v (A psi )

  REAL dust_cS	         ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"dust"))
  REAL D1_dust_cS	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dust"))
  REAL DA_dust_cS	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"dust"))


! *****************
! ***   FLUID   ***
! *****************

! Rest-mass energy density in comoving frame.

  REAL fluid_rho	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Specific internal energy (internal energy per unit mass) in comoving frame.

  REAL fluid_e	         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Pressure in comoving frame.

  REAL fluid_p	         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Specific enthalpy in comoving frame: h = (1 + e + p/rho0).

  REAL fluid_h	         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Velocity of fluid elements as seen by Eulerian observers (index up).

  REAL fluid_v	         ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Lorentz factor: W = 1 / sqrt(1  -  A psi**4 v**2).

  REAL fluid_W	         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Speed of sound.

  REAL fluid_vs	         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Mach number v/vs.

  REAL fluid_Mach	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Characteristic speeds.

  REAL fluid_vcp	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))
  REAL fluid_vcm	 ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Conserved rest-mass energy density measured by Eulerian observers:
!
! cD  =  fluid_rho W
!
! where W is the Lorentz factor given by:
!
!        mu                                i  j                          4  2
! W = - u  n   =  1 / sqrt ( 1  -  gamma  v  v  )  =  1 / sqrt( 1 - A psi  v  )
!           mu                          ij
!

  REAL fluid_cD          ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))
  REAL D1_fluid_cD       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))
  REAL DA_fluid_cD       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Conserved energy density measured bu Eulerian observers (difference
! between total energy density and rest-mass energy density):
!
!                                        2
! cE  =  rho    -   p  -  cD  =  rho0 h W  -  p  -  cD
!           ADM
!

  REAL fluid_cE          ! SYMMETRY = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))
  REAL D1_fluid_cE       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))
  REAL DA_fluid_cE       ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Conserved momentum density measured by Eulerian observers (index down):
!
!                2        4
! cS  =  rho0 h W v (A psi )

  REAL fluid_cS	         ! SYMMETRY = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))
  REAL D1_fluid_cS       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))
  REAL DA_fluid_cS       ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))

! Pressure associated with artificial viscosity.

  REAL fluid_q	         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (contains(mattertype,"fluid"))


! *********************
! ***   COSMOLOGY   ***
! *********************

! Background proper time.

  REAL cosmobg_tau       ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD

! Background Hubble parameter and scale factor.

  REAL cosmobg_H         ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD
  REAL cosmobg_a         ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD

! Background conformal factor and trK.

  REAL cosmobg_phi       ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD
  REAL cosmobg_trK       ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD

! Background lapse and Bona-Masso gauge function.

  REAL cosmobg_alpha     ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD
  REAL cosmobg_falpha    ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run), ZEROD

! Background speed of light.

  REAL cosmobg_vlight    ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run), ZEROD

! Backgroung matter density and pressure.

  REAL cosmobg_rho       ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run), ZEROD
  REAL cosmobg_p         ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run), ZEROD

! Perturbed geometric quantities (minus the background).

  REAL alpha_pert        ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run)
  REAL phi_pert          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run)
  REAL trK_pert          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run)

! Perturbed density, density contrast, integral of density constrast, and compactness.

  REAL rho_pert          ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run)
  REAL rho_contrast      ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run)
  REAL rho_pert_int      ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run)
  REAL rho_contrast_int  ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run)
  REAL cosmo_compactness ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run)

! Background quantities for a real scalar field.

  REAL cosmobg_scalar_phi   ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD
  REAL cosmobg_scalar_pi    ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD

  REAL cosmobg_scalar_V     ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run), ZEROD
  REAL cosmobg_scalar_VP    ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run), ZEROD

! Background quantities for a complex scalar field.

  REAL cosmobg_complex_phiR ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD
  REAL cosmobg_complex_phiI ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD

  REAL cosmobg_complex_piR  ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD
  REAL cosmobg_complex_piI  ! SYMMETRY = 0, INTENT = EVOLVE, STORAGE = CONDITIONAL (cosmic_run), ZEROD

  REAL cosmobg_complex_V    ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run), ZEROD
  REAL cosmobg_complex_VPR  ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run), ZEROD
  REAL cosmobg_complex_VPI  ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = CONDITIONAL (cosmic_run), ZEROD


! ***************************************
! ***   RADIAL COORDINATE TRANSFORM   ***
! ***************************************

  REAL r_trans           ! SYMMETRY = 0, INTENT = AUXILIARY, STORAGE = CONDITIONAL(newr)

! REAL A_trans           ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(newr)
! REAL D1_Atrans         ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(newr)
! REAL D2_Atrans         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(newr)

! REAL B_trans           ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(newr)
! REAL D1_Btrans         ! SYMMETRY = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(newr)
! REAL D2_Btrans         ! SYMMETRY = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(newr)

